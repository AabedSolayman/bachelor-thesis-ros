#include "ros/ros.h"
#include <tf2/LinearMath/Quaternion.h>
#include "obstacle_detector/Obstacles.h"
#include "geometry_msgs/Pose.h"
#include "geometry_msgs/PoseStamped.h"
#include "geometry_msgs/Point.h"
#include "math.h"
#include "time.h"
#include <list.h>



class PoseFinder {

private:
	geometry_msgs::Point pointTop;
	geometry_msgs::Point pointBottom;
	geometry_msgs::Pose robotPose_;
	geometry_msgs::PoseStamped foo;

	double yawRad = 0;
	int x = 0;
	tf2::Quaternion robotOrientation;
	ros::Publisher posePublisher;
	ros::Subscriber subTop;
	ros::Subscriber sub_bottom;
	ros::NodeHandle n;

public:
	PoseFinder() {

		subTop = n.subscribe("/lidar_top/raw_obstacles", 1000,
				&PoseFinder::obstaclesTopCallback, this);

		sub_bottom = n.subscribe("/lidar_bottom/raw_obstacles", 1000,
				&PoseFinder::obstaclesTopCallback, this);

		posePublisher = n.advertise<geometry_msgs::PoseStamped>("robot_pose", 1000);
		x = 100;
		robotPosePublisher();
		ros::spin();

	}

	void obstaclesTopCallback(
			const obstacle_detector::Obstacles::ConstPtr &msg) {
		pointTop = msg->circles[0].center;

	}

	void obstaclesBottomCallback(
			const obstacle_detector::Obstacles::ConstPtr &msg) {
		pointBottom = msg->circles[0].center;
	}

	void robotPosePublisher() {
		while (ros::ok()) {
			foo.header.frame_id= "/base_footprint";
			foo.header.stamp = ros::Time::now();
			foo.pose = robotPose();

			posePublisher.publish(foo);
			ros::spinOnce();
			ros::Rate loop_rate(10);
			loop_rate.sleep();

		}
	}

	geometry_msgs::Pose robotPose() {
		if(pointTop.x != n)
		robotPose_.position.x = (pointTop.x - pointBottom.x) / 2;
		robotPose_.position.y = (pointTop.y - pointBottom.y) / 2;

		yawRad = atan2(robotPose_.position.y, robotPose_.position.x);

		robotOrientation.setRPY(0, 0, yawRad);

		robotPose_.orientation.x = robotOrientation.getX();
		robotPose_.orientation.y = robotOrientation.getY();
		robotPose_.orientation.z = robotOrientation.getZ();
		robotPose_.orientation.w = robotOrientation.getW();

		return robotPose_;
	}

};

int main(int argc, char **argv) {

	ros::init(argc, argv, "pose_detector");
    list<int>  mylist = {0, 1, 2, 3, 4};


	PoseFinder pF;
	return 0;
}
