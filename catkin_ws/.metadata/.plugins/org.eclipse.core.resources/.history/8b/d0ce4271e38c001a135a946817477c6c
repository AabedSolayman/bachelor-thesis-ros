#include "ros/ros.h"
#include <tf2/LinearMath/Quaternion.h>
#include "obstacle_detector/Obstacles.h"
#include "geometry_msgs/Pose.h"
#include "geometry_msgs/Point.h"
#include "math.h"




class PoseFinder
{
private:
	geometry_msgs:: Point point_top;
	geometry_msgs:: Point point_bottom;
	geometry_msgs:: Pose robot_pose;
	double yaw_degrees = 0;
	tf2::Quaternion robot_orientation;
public:
	PoseFinder(){
		ros::NodeHandle n;
		ros::Subscriber sub_top = n.subscribe("/lidar_top/raw_obstacles",1000,obstaclesTopCallback);
		ros::Subscriber sub_bottom = n.subscribe("/lidar_bottom/raw_obstacles",1000,obstaclesTopCallback);

	}



void obstaclesTopCallback(const obstacle_detector::Obstacles::ConstPtr& msg)
{
	point_top = msg->circles[0].center;

}

void obstaclesBottomCallback(const obstacle_detector::Obstacles::ConstPtr& msg)
{
	point_bottom= msg->circles[0].center;
}

geometry_msgs:: Pose robotPose(){
	robot_pose.position = (point_top-point_bottom)/2;

	yaw_degrees = atan2(robot_pose.position.y, robot_pose.position.x);

	robot_orientation.setRPY(0,0,yaw_degrees);

	robot_pose.orientation = robot_orientation;


	return robot_pose;
}

};

int main(int argc, char **argv)
{

	ros::init(argc, argv, "obstacles_listener");

	ros::spin();


}
