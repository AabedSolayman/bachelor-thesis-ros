#include "ros/ros.h"
#include <tf2/LinearMath/Quaternion.h>
#include "obstacle_detector/Obstacles.h"
#include "geometry_msgs/Pose.h"
#include "geometry_msgs/TransformStamped.h"
#include "geometry_msgs/Point.h"
#include "math.h"
#include <iostream>

#include <tf2_ros/transform_broadcaster.h>

class PoseFinder {

private:
	geometry_msgs::Point pointTop;
	geometry_msgs::Point pointBottom;
	geometry_msgs::Pose robotPose_;
	geometry_msgs::TransformStamped robotTransformStamped;
	geometry_msgs::TransformStamped robotTransform_;

	double yawRad = 0;
	tf2::Quaternion robotOrientation;
	ros::Publisher posePublisher;
	ros::Subscriber subTop;
	ros::Subscriber sub_bottom;
	ros::NodeHandle n;

public:
	PoseFinder() {

		subTop = n.subscribe("/lidar_top/raw_obstacles", 1000,
				&PoseFinder::obstaclesTopCallback, this);

		sub_bottom = n.subscribe("/lidar_bottom/raw_obstacles", 1000,
				&PoseFinder::obstaclesBottomCallback, this);

		posePublisher = n.advertise<geometry_msgs::TransformStamped>(
				"robot_pose", 1000);
		robotTfPublisher();
		ros::spin();

	}

	void obstaclesTopCallback(
			const obstacle_detector::Obstacles::ConstPtr &msg) {

		if (!msg->circles.empty())
			pointTop = msg->circles[0].center;

	}

	void obstaclesBottomCallback(
			const obstacle_detector::Obstacles::ConstPtr &msg) {

		if (!msg->circles.empty())
			pointBottom = msg->circles[0].center;
	}

	void robotTfPublisher() {
		while (ros::ok()) {
			robotTransformStamped.header.frame_id = "/map";
			robotTransformStamped.child_frame_id = "/robot";
			robotTransformStamped.header.stamp = ros::Time::now();

			robotTransformStamped.transform = robotTransform();

			static tf2_ros::TransformBroadcaster br;

			br.sendTransform(robotTransformStamped);
			ros::spinOnce();
			ros::Rate loop_rate(10);
			loop_rate.sleep();

		}
	}

	geometry_msgs::Transform robotTransform() {
		robotTransform_.transform.translation.x = (pointTop.x + pointBottom.x) / 2;
		robotTransform_.transform.translation.y = (pointTop.y + pointBottom.y) / 2;

		yawRad = atan2(robotTransform_.transform.translation.y,
					   robotTransform_.transform.translation.x);

		robotTransform_.transform.rotation = robotOrientation.setRPY(0, 0,yawRad);

		return robotTransform_;
	}

};

int main(int argc, char **argv) {

	ros::init(argc, argv, "pose_detector");

	PoseFinder pF;
	return 0;
}
